<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Pain-free Python Fastapi RabbitMQ Integration | fahrizain</title>
<meta name=keywords content="messagebroker,rabbitmq,fastapi,python"><meta name=description content="Despite of the powerfulness of FastAPI, I found it's not easy to work with threads and RabbitMQ. I was struggled for 3 days to find the solution. And here I'll share my findings on creating both RMQ based producer and consumer in single FastAPI app."><meta name=author content="Affandy Fahrizain"><link rel=canonical href=https://fhrzn.github.io/posts/pain-free-python-fastapi-rmq-integration/><link crossorigin=anonymous href=/assets/css/stylesheet.f0568d4df87da526a07cdd5f492b4a146e3fa93d5ee950200eaafb2bb50d6fd8.css integrity="sha256-8FaNTfh9pSagfN1fSStKFG4/qT1e6VAgDqr7K7UNb9g=" rel="preload stylesheet" as=style><link rel=icon href=https://fhrzn.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://fhrzn.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://fhrzn.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://fhrzn.github.io/apple-touch-icon.png><link rel=mask-icon href=https://fhrzn.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/katex.min.css integrity=sha384-MlJdn/WNKDGXveldHDdyRP1R4CTHr3FeuDNfhsLPYrq2t0UBkUdK2jyTnXPEK1NQ crossorigin=anonymous referrerpolicy=no-referrer><script defer src=https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/katex.min.js integrity=sha384-VQ8d8WVFw0yHhCk5E8I86oOhv48xLpnDZx5T9GogA/Y84DcCKWXDmSDfn13bzFZY crossorigin=anonymous referrerpolicy=no-referrer type=text/javascript></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/contrib/auto-render.min.js integrity=sha384-+XBljXPPiv+OzfbB3cVmLHf4hdUFHlWNZN5spNQ7rmHTXpd7WvJum6fIACpNNfIR crossorigin=anonymous referrerpolicy=no-referrer type=text/javascript></script><script type=text/javascript>document.addEventListener("DOMContentLoaded",function(){renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"\\[",right:"\\]",display:!0},{left:"$",right:"$",display:!1},{left:"\\(",right:"\\)",display:!1}]})})</script><script async src="https://www.googletagmanager.com/gtag/js?id=G-27DEESLMGL"></script><script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-27DEESLMGL")</script><meta property="og:title" content="Pain-free Python Fastapi RabbitMQ Integration"><meta property="og:description" content="Despite of the powerfulness of FastAPI, I found it's not easy to work with threads and RabbitMQ. I was struggled for 3 days to find the solution. And here I'll share my findings on creating both RMQ based producer and consumer in single FastAPI app."><meta property="og:type" content="article"><meta property="og:url" content="https://fhrzn.github.io/posts/pain-free-python-fastapi-rmq-integration/"><meta property="og:image" content="https://fhrzn.github.io/posts/pain-free-python-fastapi-rmq-integration/cover.jpeg"><meta property="article:section" content="posts"><meta property="article:published_time" content="2024-02-10T06:55:09+07:00"><meta property="article:modified_time" content="2024-02-10T06:55:09+07:00"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://fhrzn.github.io/posts/pain-free-python-fastapi-rmq-integration/cover.jpeg"><meta name=twitter:title content="Pain-free Python Fastapi RabbitMQ Integration"><meta name=twitter:description content="Despite of the powerfulness of FastAPI, I found it's not easy to work with threads and RabbitMQ. I was struggled for 3 days to find the solution. And here I'll share my findings on creating both RMQ based producer and consumer in single FastAPI app."><meta name=twitter:site content="@fhrzn_"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://fhrzn.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Pain-free Python Fastapi RabbitMQ Integration","item":"https://fhrzn.github.io/posts/pain-free-python-fastapi-rmq-integration/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Pain-free Python Fastapi RabbitMQ Integration","name":"Pain-free Python Fastapi RabbitMQ Integration","description":"Despite of the powerfulness of FastAPI, I found it's not easy to work with threads and RabbitMQ. I was struggled for 3 days to find the solution. And here I'll share my findings on creating both RMQ based producer and consumer in single FastAPI app.","keywords":["messagebroker","rabbitmq","fastapi","python"],"articleBody":"Background I was working on implementing RabbitMQ (RMQ) in FastAPI for doing background task. Initially, there was a long process in our system, and the execution time is not deterministic. Making the some request caught in the timeout error. To solve it, we come up with a message broker based solution.\nIn this case, our system has to communicate with itself to do the long process in the background. So the origin request won’t be expired. Optionally, once the process is done it can be asked to notify the user.\nThe illustration of our FastAPI interaction with RabbitMQ producer and consumer.\nPub/Sub Pattern The publisher/subscriber pattern using message broker is one of the common pattern. It also covered in the official documentation of RabbitMQ. However, the common pattern is to have publisher and consumer as different application because usually the communication is happened between two or more services. While in our case, we don’t want to create another service just for processing our task in background. Therefore, we need to have both publisher and subscriber in a single service.\nUsually, in more complex system there could be multiple publisher and subscriber for different events. But in this case, we will demonstrate it using only one publisher and subscriber which we will call it as producer and consumer. The simple illustration of single pub/sub.\nIntegration with FastAPI Initially, I did my experiments by running producer and consumer in dedicated threads; and using asyncio connection. The threads solution always gave me an error pika.exceptions.StreamLostError: Stream connection lost: BrokenPipeError(32, 'Broken pipe') after idle for several minutes. While the asyncio based one always blocking the same thread that used to serve endpoint routes. Meaning when the background process is running, any calls to the endpoints should be wait for it to be finished.\nFinally, I found the solution using aio-pika library, and the decided to built my solution on top of it. So, let’s start demonstrate it using simple FastAPI project.\nNote: I won’t explain basic terms and definitions of each RMQ part. Feel free to visit their official tutorial to better understand the terms and definitions\nRabbitMQ (Pika) documentation\naio-pika documentation\nFirst thing first, lets create a rmq.py file for our PikaClient which will be interact with RMQ.\nimport logging import aio_pika import asyncio logger = logging.getLogger(__name__) class PikaClient(): def __init__(self, queue_name: str, exchange_name: str, conn_str: str) -\u003e None: self.queue_name = queue_name self.exchange_name = exchange_name self.conn_str = conn_str self.connection = None self.channel = None self.exchange = None self.queue = None async def start_connection(self): logger.info(\"Starting a new connection\") self.connection = await aio_pika.connect_robust(url=self.conn_str) logger.info(\"Opening a new channel\") self.channel = await self.connection.channel() logger.info(\"Declaring an exchange: %s\" % self.exchange_name) self.exchange = await self.channel.declare_exchange(name=self.exchange_name, type=aio_pika.ExchangeType.DIRECT) await self.setup_queue() async def setup_queue(self): logger.info(\"Setup a queue: %s\" % self.queue_name) self.queue = await self.channel.declare_queue(name=self.queue_name) logger.info(\"Bind queue to exchange\") await self.queue.bind(self.exchange) async def disconnect(self): try: if not self.connection.is_closed: await self.connection.close() except Exception as _e: logger.error(_e) Here we just created the basic interface for interacting with RMQ. It consists of starting a new RMQ connection, opening a new channel, declaring an exchange, and setup a queue.\nThen, let’s add the following functions to enable run PikaClient as producer.\nasync def start_producer(self): await self.start_connection() logger.info(\"Producer has been started\") return self async def publish_message(self, message): await self.exchange.publish( aio_pika.Message(body=message.encode()), routing_key=self.queue_name ) Once the client is connected and ran in producer mode, it can call publish_message() at any time to send the message to RMQ.\nNow, let’s continue add the following functions for enabling run as consumer.\nasync def start_consumer(self): await self.start_connection() await self.channel.set_qos(prefetch_count=1) logger.info(\"Starting consumer\") await self.queue.consume(self.handle_message) logger.info(\"Consumer has been started\") return self async def handle_message(self, message: aio_pika.abc.AbstractIncomingMessage): # simulating long process await asyncio.sleep(10) logger.info(\"Consumer: Got message from producer: %s\" % message.body.decode()) await message.ack() Here, we need to set few things up at the initial connection.\nThe channel.set_qos() define how many job allowed to be executed concurrently. The queue.consume(callback) trigger the consumer to subscribe/listen to the predefined queue, waiting for any new message.\nThe callback function (in this case handle_message()) is executed rightaway the message arrived in RMQ. Note that we simulating the long background process using asyncio.sleep(10). Later you will see that during long process simulation, the user still able to navigate through our endpoints without getting blcoked.\nFinally, message.ack() is used to mark that the message is received successfully.\nNow, let’s move to main.py and setup our FastAPI application.\nfrom fastapi import FastAPI, Request, Response import logging from rmq import PikaClient logging.basicConfig(level=logging.INFO, format=\"%(asctime)s %(levelname)s: %(name)s - %(message)s\") logger = logging.getLogger(__name__) app = FastAPI() @app.on_event(\"startup\") async def start_rmq(): pass @app.on_event(\"shutdown\") async def shutdown_rmq(): pass @app.get(\"/\") def root(response: Response): response.status_code = 200 logger.info(\"hit root endpoint\") return {\"status_code\": 200, \"message\": \"Hello!\"} @app.get(\"/send-message\") async def send_message(request: Request, response: Response): pass Here, we will have 2 endpoints for demonstrating our background jobs and regular endpoint for which user or another service can interact with our system. We also have both startup and shutdown FastAPI event which we will use it to start and stop our RMQ producer and consumer.\nLet’s start with setup the producer.\n@app.on_event(\"startup\") async def start_rmq(): # start producer app.rmq_producer = PikaClient(queue_name=\"test.queue\", exchange_name=\"test.exchange\", conn_str=\"amqp://root:root@127.0.0.1:5672\") await app.rmq_producer.start_producer() @app.on_event(\"shutdown\") async def shutdown_rmq(): await app.rmq_producer.disconnect() Quite simple, once the application start it will create a PikaClient object and call start_producer() to run it as producer. And once the application is stopped it will call the disconnect() to stop the producer.\nNow, let’s implement the similar thing to consumer with slight difference. We will run the consumer in a different thread so it won’t block the thread that FastAPI used for serving endpoint routes.\ndef start_background_loop(loop: asyncio.AbstractEventLoop) -\u003e None: # inspired from https://gist.github.com/dmfigol/3e7d5b84a16d076df02baa9f53271058 asyncio.set_event_loop(loop) loop.run_forever() @app.on_event(\"startup\") async def start_rmq(): # start producer app.rmq_producer = PikaClient(queue_name=\"test.queue\", exchange_name=\"test.exchange\", conn_str=\"amqp://root:root@127.0.0.1:5672\") await app.rmq_producer.start_producer() # start consumer in other thread app.rmq_consumer = PikaClient(queue_name=\"test.queue\", exchange_name=\"test.exchange\", conn_str=\"amqp://root:root@127.0.0.1:5672\") app.consumer_loop = asyncio.new_event_loop() tloop = threading.Thread(target=start_background_loop, args=(app.consumer_loop,), daemon=True) tloop.start() _ = asyncio.run_coroutine_threadsafe(app.rmq_consumer.start_consumer(), app.consumer_loop) @app.on_event(\"shutdown\") async def shutdown_rmq(): await app.rmq_producer.disconnect() await app.rmq_consumer.disconnect() app.consumer_loop.stop() Here, inside the startup event we initiated a new asyncio event loop. Then, we trigger that loop to be run from another thread. We then delegate the start_consumer() calls to the loop, so the consumer will executed in the newly created thread. Finally, inside the shutdown event, we also call disconnect() to stop consumer RMQ from subscribing the queue. And we also trigger our created asyncio event loop to stop.\nThe final codes would be like this.\nrmq.py\nimport logging import aio_pika import asyncio logger = logging.getLogger(__name__) class PikaClient(): def __init__(self, queue_name: str, exchange_name: str, conn_str: str) -\u003e None: self.queue_name = queue_name self.exchange_name = exchange_name self.conn_str = conn_str self.connection = None self.channel = None self.exchange = None self.queue = None async def start_connection(self): logger.info(\"Starting a new connection\") self.connection = await aio_pika.connect_robust(url=self.conn_str) logger.info(\"Opening a new channel\") self.channel = await self.connection.channel() logger.info(\"Declaring an exchange: %s\" % self.exchange_name) self.exchange = await self.channel.declare_exchange(name=self.exchange_name, type=aio_pika.ExchangeType.DIRECT) await self.setup_queue() async def setup_queue(self): logger.info(\"Setup a queue: %s\" % self.queue_name) self.queue = await self.channel.declare_queue(name=self.queue_name) logger.info(\"Bind queue to exchange\") await self.queue.bind(self.exchange) async def start_producer(self): await self.start_connection() logger.info(\"Producer has been started\") return self async def publish_message(self, message): await self.exchange.publish( aio_pika.Message(body=message.encode()), routing_key=self.queue_name ) async def start_consumer(self): await self.start_connection() await self.channel.set_qos(prefetch_count=1) logger.info(\"Starting consumer\") await self.queue.consume(self.handle_message) logger.info(\"Consumer has been started\") return self async def handle_message(self, message: aio_pika.abc.AbstractIncomingMessage): # simulating long process await asyncio.sleep(10) logger.info(\"Consumer: Got message from producer: %s\" % message.body.decode()) await message.ack() async def disconnect(self): try: if not self.connection.is_closed: await self.connection.close() except Exception as _e: logger.error(_e) main.py\nfrom fastapi import FastAPI, Request, Response import asyncio import logging from rmq import PikaClient import threading logging.basicConfig(level=logging.INFO, format=\"%(asctime)s %(levelname)s: %(name)s - %(message)s\") logger = logging.getLogger(__name__) app = FastAPI() def start_background_loop(loop: asyncio.AbstractEventLoop) -\u003e None: # inspired from https://gist.github.com/dmfigol/3e7d5b84a16d076df02baa9f53271058 asyncio.set_event_loop(loop) loop.run_forever() @app.on_event(\"startup\") async def start_rmq(): # start producer app.rmq_producer = PikaClient(queue_name=\"test.queue\", exchange_name=\"test.exchange\", conn_str=\"amqp://root:root@127.0.0.1:5672\") await app.rmq_producer.start_producer() # start consumer in other thread app.rmq_consumer = PikaClient(queue_name=\"test.queue\", exchange_name=\"test.exchange\", conn_str=\"amqp://root:root@127.0.0.1:5672\") app.consumer_loop = asyncio.new_event_loop() tloop = threading.Thread(target=start_background_loop, args=(app.consumer_loop,), daemon=True) tloop.start() _ = asyncio.run_coroutine_threadsafe(app.rmq_consumer.start_consumer(), app.consumer_loop) @app.on_event(\"shutdown\") async def shutdown_rmq(): await app.rmq_producer.disconnect() await app.rmq_consumer.disconnect() app.consumer_loop.stop() @app.get(\"/\") def root(response: Response): response.status_code = 200 logger.info(\"hit root endpoint\") return {\"status_code\": 200, \"message\": \"Hello!\"} @app.get(\"/send-message\") async def send_message(request: Request, response: Response): message = \"Hello from RMQ producer!\" response.status_code = 202 logger.info(\"message sent\") await request.app.rmq_producer.publish_message(message) return {\"status_code\": 202, \"message\": \"Your message has been sent.\"} Running the Application When we start the server, shortly we will notice both producer and consumer has started. Now, lets try to hit the long process endpoint following by several hits to the ordinary endpoint. Let’s try several more then observe our RMQ dashboard. And we can see there are some messages incoming and being processed.\nConclusion Now we know how to integrate both RMQ based publisher and subscriber within single FastAPI app.\nIf you have any inquiries, comments, suggestions, or critics please don’t hesitate to reach me out:\nMail: affahrizain@gmail.com LinkedIn: https://www.linkedin.com/in/fahrizainn/ GitHub: https://github.com/fhrzn Until next time! 👋\nReferences https://www.rabbitmq.com/tutorials/tutorial-one-python.html https://aio-pika.readthedocs.io/en/latest/quick-start.html#asynchronous-message-processing RabbitMQ publisher and consumer with FastAPI by IT racer Gist python asyncio event loop in a separated thread by dmfigol ","wordCount":"1477","inLanguage":"en","image":"https://fhrzn.github.io/posts/pain-free-python-fastapi-rmq-integration/cover.jpeg","datePublished":"2024-02-10T06:55:09+07:00","dateModified":"2024-02-10T06:55:09+07:00","author":{"@type":"Person","name":"Affandy Fahrizain"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://fhrzn.github.io/posts/pain-free-python-fastapi-rmq-integration/"},"publisher":{"@type":"Organization","name":"fahrizain","logo":{"@type":"ImageObject","url":"https://fhrzn.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://fhrzn.github.io/ accesskey=h title="fahrizain (Alt + H)"><img src=https://fhrzn.github.io/favicon-32x32.png alt aria-label=logo height=30>fahrizain</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">Pain-free Python Fastapi RabbitMQ Integration</h1><div class=post-description>Despite of the powerfulness of FastAPI, I found it's not easy to work with threads and RabbitMQ. I was struggled for 3 days to find the solution. And here I'll share my findings on creating both RMQ based producer and consumer in single FastAPI app.</div><div class=post-meta><span title='2024-02-10 06:55:09 +0700 WIB'>February 10, 2024</span>&nbsp;·&nbsp;7 min&nbsp;·&nbsp;1477 words&nbsp;·&nbsp;Affandy Fahrizain</div></header><figure class=entry-cover><img loading=eager srcset="https://fhrzn.github.io/posts/pain-free-python-fastapi-rmq-integration/cover_huac222b9b72463efe967d69511a89bad5_103226_360x0_resize_q75_box.jpeg 360w ,https://fhrzn.github.io/posts/pain-free-python-fastapi-rmq-integration/cover_huac222b9b72463efe967d69511a89bad5_103226_480x0_resize_q75_box.jpeg 480w ,https://fhrzn.github.io/posts/pain-free-python-fastapi-rmq-integration/cover_huac222b9b72463efe967d69511a89bad5_103226_720x0_resize_q75_box.jpeg 720w ,https://fhrzn.github.io/posts/pain-free-python-fastapi-rmq-integration/cover.jpeg 1024w" sizes="(min-width: 768px) 720px, 100vw" src=https://fhrzn.github.io/posts/pain-free-python-fastapi-rmq-integration/cover.jpeg alt="Three pikachus delivering packages" width=1024 height=1024><p>This image was generated using Bing Image Creator by Microsoft</p></figure><div class=post-content><h2 id=background>Background<a hidden class=anchor aria-hidden=true href=#background>#</a></h2><p>I was working on implementing RabbitMQ (RMQ) in FastAPI for doing background task. Initially, there was a long process in our system, and the execution time is not deterministic. Making the some request caught in the timeout error. To solve it, we come up with a message broker based solution.</p><p>In this case, our system has to communicate with itself to do the long process in the background. So the origin request won&rsquo;t be expired. Optionally, once the process is done it can be asked to notify the user.</p><p><img loading=lazy src=images/system.png#center alt="Illustration of the system">
The illustration of our FastAPI interaction with RabbitMQ producer and consumer.</p><h2 id=pubsub-pattern>Pub/Sub Pattern<a hidden class=anchor aria-hidden=true href=#pubsub-pattern>#</a></h2><p>The publisher/subscriber pattern using message broker is one of the common pattern. It also covered in the <a href=https://www.rabbitmq.com/tutorials/tutorial-three-python.html>official documentation of RabbitMQ</a>. However, the common pattern is to have publisher and consumer as different application because usually the communication is happened between two or more services. While in our case, we don&rsquo;t want to create another service just for processing our task in background. Therefore, we need to have both publisher and subscriber in a single service.</p><p>Usually, in more complex system there could be multiple publisher and subscriber for different events. But in this case, we will demonstrate it using only one publisher and subscriber which we will call it as producer and consumer.
<img loading=lazy src=images/pubsub.png#center alt="pub/sub illustration">
The simple illustration of single pub/sub.</p><h2 id=integration-with-fastapi>Integration with FastAPI<a hidden class=anchor aria-hidden=true href=#integration-with-fastapi>#</a></h2><p>Initially, I did my experiments by running producer and consumer in dedicated threads; and using asyncio connection. The threads solution always gave me an error <code>pika.exceptions.StreamLostError: Stream connection lost: BrokenPipeError(32, 'Broken pipe')</code> after idle for several minutes. While the asyncio based one always blocking the same thread that used to serve endpoint routes. Meaning when the background process is running, any calls to the endpoints should be wait for it to be finished.</p><p>Finally, I found the solution using <a href=https://aio-pika.readthedocs.io/en/latest/><code>aio-pika</code></a> library, and the decided to built my solution on top of it. So, let&rsquo;s start demonstrate it using simple FastAPI project.</p><blockquote><p><em>Note: I won&rsquo;t explain basic terms and definitions of each RMQ part. Feel free to visit their official tutorial to better understand the terms and definitions</em></p><p><a href=https://www.rabbitmq.com/tutorials/tutorial-one-python.html>RabbitMQ (Pika) documentation</a></p><p><a href=https://aio-pika.readthedocs.io/en/latest/><code>aio-pika</code> documentation</a></p></blockquote><p>First thing first, lets create a <code>rmq.py</code> file for our <code>PikaClient</code> which will be interact with RMQ.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python3 data-lang=python3><span style=display:flex><span><span style=color:#f92672>import</span> logging
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> aio_pika
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> asyncio
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>logger <span style=color:#f92672>=</span> logging<span style=color:#f92672>.</span>getLogger(__name__)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>PikaClient</span>():
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> __init__(self, queue_name: str, exchange_name: str, conn_str: str) <span style=color:#f92672>-&gt;</span> <span style=color:#66d9ef>None</span>:
</span></span><span style=display:flex><span>        self<span style=color:#f92672>.</span>queue_name <span style=color:#f92672>=</span> queue_name
</span></span><span style=display:flex><span>        self<span style=color:#f92672>.</span>exchange_name <span style=color:#f92672>=</span> exchange_name
</span></span><span style=display:flex><span>        self<span style=color:#f92672>.</span>conn_str <span style=color:#f92672>=</span> conn_str
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        self<span style=color:#f92672>.</span>connection <span style=color:#f92672>=</span> <span style=color:#66d9ef>None</span>
</span></span><span style=display:flex><span>        self<span style=color:#f92672>.</span>channel <span style=color:#f92672>=</span> <span style=color:#66d9ef>None</span>
</span></span><span style=display:flex><span>        self<span style=color:#f92672>.</span>exchange <span style=color:#f92672>=</span> <span style=color:#66d9ef>None</span>
</span></span><span style=display:flex><span>        self<span style=color:#f92672>.</span>queue <span style=color:#f92672>=</span> <span style=color:#66d9ef>None</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>async</span> <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>start_connection</span>(self):
</span></span><span style=display:flex><span>        logger<span style=color:#f92672>.</span>info(<span style=color:#e6db74>&#34;Starting a new connection&#34;</span>)
</span></span><span style=display:flex><span>        self<span style=color:#f92672>.</span>connection <span style=color:#f92672>=</span> <span style=color:#66d9ef>await</span> aio_pika<span style=color:#f92672>.</span>connect_robust(url<span style=color:#f92672>=</span>self<span style=color:#f92672>.</span>conn_str)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        logger<span style=color:#f92672>.</span>info(<span style=color:#e6db74>&#34;Opening a new channel&#34;</span>)
</span></span><span style=display:flex><span>        self<span style=color:#f92672>.</span>channel <span style=color:#f92672>=</span> <span style=color:#66d9ef>await</span> self<span style=color:#f92672>.</span>connection<span style=color:#f92672>.</span>channel()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        logger<span style=color:#f92672>.</span>info(<span style=color:#e6db74>&#34;Declaring an exchange: </span><span style=color:#e6db74>%s</span><span style=color:#e6db74>&#34;</span> <span style=color:#f92672>%</span> self<span style=color:#f92672>.</span>exchange_name)
</span></span><span style=display:flex><span>        self<span style=color:#f92672>.</span>exchange <span style=color:#f92672>=</span> <span style=color:#66d9ef>await</span> self<span style=color:#f92672>.</span>channel<span style=color:#f92672>.</span>declare_exchange(name<span style=color:#f92672>=</span>self<span style=color:#f92672>.</span>exchange_name, type<span style=color:#f92672>=</span>aio_pika<span style=color:#f92672>.</span>ExchangeType<span style=color:#f92672>.</span>DIRECT)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>await</span> self<span style=color:#f92672>.</span>setup_queue()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>async</span> <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>setup_queue</span>(self):
</span></span><span style=display:flex><span>        logger<span style=color:#f92672>.</span>info(<span style=color:#e6db74>&#34;Setup a queue: </span><span style=color:#e6db74>%s</span><span style=color:#e6db74>&#34;</span> <span style=color:#f92672>%</span> self<span style=color:#f92672>.</span>queue_name)
</span></span><span style=display:flex><span>        self<span style=color:#f92672>.</span>queue <span style=color:#f92672>=</span> <span style=color:#66d9ef>await</span> self<span style=color:#f92672>.</span>channel<span style=color:#f92672>.</span>declare_queue(name<span style=color:#f92672>=</span>self<span style=color:#f92672>.</span>queue_name)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        logger<span style=color:#f92672>.</span>info(<span style=color:#e6db74>&#34;Bind queue to exchange&#34;</span>)
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>await</span> self<span style=color:#f92672>.</span>queue<span style=color:#f92672>.</span>bind(self<span style=color:#f92672>.</span>exchange)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>async</span> <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>disconnect</span>(self):
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>try</span>:
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> <span style=color:#f92672>not</span> self<span style=color:#f92672>.</span>connection<span style=color:#f92672>.</span>is_closed:
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>await</span> self<span style=color:#f92672>.</span>connection<span style=color:#f92672>.</span>close()
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>except</span> <span style=color:#a6e22e>Exception</span> <span style=color:#66d9ef>as</span> _e:
</span></span><span style=display:flex><span>            logger<span style=color:#f92672>.</span>error(_e)
</span></span></code></pre></div><p>Here we just created the basic interface for interacting with RMQ. It consists of starting a new RMQ connection, opening a new channel, declaring an exchange, and setup a queue.</p><p>Then, let&rsquo;s add the following functions to enable run <code>PikaClient</code> as producer.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python3 data-lang=python3><span style=display:flex><span>    <span style=color:#66d9ef>async</span> <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>start_producer</span>(self):
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>await</span> self<span style=color:#f92672>.</span>start_connection()
</span></span><span style=display:flex><span>        logger<span style=color:#f92672>.</span>info(<span style=color:#e6db74>&#34;Producer has been started&#34;</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> self
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>async</span> <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>publish_message</span>(self, message):
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>await</span> self<span style=color:#f92672>.</span>exchange<span style=color:#f92672>.</span>publish(
</span></span><span style=display:flex><span>            aio_pika<span style=color:#f92672>.</span>Message(body<span style=color:#f92672>=</span>message<span style=color:#f92672>.</span>encode()),
</span></span><span style=display:flex><span>            routing_key<span style=color:#f92672>=</span>self<span style=color:#f92672>.</span>queue_name
</span></span><span style=display:flex><span>        )
</span></span></code></pre></div><p>Once the client is connected and ran in producer mode, it can call <code>publish_message()</code> at any time to send the message to RMQ.</p><p>Now, let&rsquo;s continue add the following functions for enabling run as consumer.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python3 data-lang=python3><span style=display:flex><span>    <span style=color:#66d9ef>async</span> <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>start_consumer</span>(self):
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>await</span> self<span style=color:#f92672>.</span>start_connection()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>await</span> self<span style=color:#f92672>.</span>channel<span style=color:#f92672>.</span>set_qos(prefetch_count<span style=color:#f92672>=</span><span style=color:#ae81ff>1</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        logger<span style=color:#f92672>.</span>info(<span style=color:#e6db74>&#34;Starting consumer&#34;</span>)
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>await</span> self<span style=color:#f92672>.</span>queue<span style=color:#f92672>.</span>consume(self<span style=color:#f92672>.</span>handle_message)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        logger<span style=color:#f92672>.</span>info(<span style=color:#e6db74>&#34;Consumer has been started&#34;</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> self
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>async</span> <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>handle_message</span>(self, message: aio_pika<span style=color:#f92672>.</span>abc<span style=color:#f92672>.</span>AbstractIncomingMessage):
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e># simulating long process</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>await</span> asyncio<span style=color:#f92672>.</span>sleep(<span style=color:#ae81ff>10</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        logger<span style=color:#f92672>.</span>info(<span style=color:#e6db74>&#34;Consumer: Got message from producer: </span><span style=color:#e6db74>%s</span><span style=color:#e6db74>&#34;</span> <span style=color:#f92672>%</span> message<span style=color:#f92672>.</span>body<span style=color:#f92672>.</span>decode())
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>await</span> message<span style=color:#f92672>.</span>ack()
</span></span></code></pre></div><p>Here, we need to set few things up at the initial connection.</p><p>The <code>channel.set_qos()</code> define how many job allowed to be executed concurrently. The <code>queue.consume(callback)</code> trigger the consumer to subscribe/listen to the predefined queue, waiting for any new message.</p><p>The callback function (in this case <code>handle_message()</code>) is executed rightaway the message arrived in RMQ. Note that we simulating the long background process using <code>asyncio.sleep(10)</code>. Later you will see that during long process simulation, the user still able to navigate through our endpoints without getting blcoked.</p><p>Finally, <code>message.ack()</code> is used to mark that the message is received successfully.</p><p>Now, let&rsquo;s move to <code>main.py</code> and setup our FastAPI application.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python3 data-lang=python3><span style=display:flex><span><span style=color:#f92672>from</span> fastapi <span style=color:#f92672>import</span> FastAPI, Request, Response
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> logging
</span></span><span style=display:flex><span><span style=color:#f92672>from</span> rmq <span style=color:#f92672>import</span> PikaClient
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>logging<span style=color:#f92672>.</span>basicConfig(level<span style=color:#f92672>=</span>logging<span style=color:#f92672>.</span>INFO, format<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;</span><span style=color:#e6db74>%(asctime)s</span><span style=color:#e6db74> </span><span style=color:#e6db74>%(levelname)s</span><span style=color:#e6db74>: </span><span style=color:#e6db74>%(name)s</span><span style=color:#e6db74> - </span><span style=color:#e6db74>%(message)s</span><span style=color:#e6db74>&#34;</span>)
</span></span><span style=display:flex><span>logger <span style=color:#f92672>=</span> logging<span style=color:#f92672>.</span>getLogger(__name__)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>app <span style=color:#f92672>=</span> FastAPI()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>@app.on_event</span>(<span style=color:#e6db74>&#34;startup&#34;</span>)
</span></span><span style=display:flex><span><span style=color:#66d9ef>async</span> <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>start_rmq</span>():
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>pass</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>@app.on_event</span>(<span style=color:#e6db74>&#34;shutdown&#34;</span>)
</span></span><span style=display:flex><span><span style=color:#66d9ef>async</span> <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>shutdown_rmq</span>():
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>pass</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>@app.get</span>(<span style=color:#e6db74>&#34;/&#34;</span>)
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>root</span>(response: Response):
</span></span><span style=display:flex><span>    response<span style=color:#f92672>.</span>status_code <span style=color:#f92672>=</span> <span style=color:#ae81ff>200</span>
</span></span><span style=display:flex><span>    logger<span style=color:#f92672>.</span>info(<span style=color:#e6db74>&#34;hit root endpoint&#34;</span>)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> {<span style=color:#e6db74>&#34;status_code&#34;</span>: <span style=color:#ae81ff>200</span>, <span style=color:#e6db74>&#34;message&#34;</span>: <span style=color:#e6db74>&#34;Hello!&#34;</span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>@app.get</span>(<span style=color:#e6db74>&#34;/send-message&#34;</span>)
</span></span><span style=display:flex><span><span style=color:#66d9ef>async</span> <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>send_message</span>(request: Request, response: Response):
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>pass</span>
</span></span></code></pre></div><p>Here, we will have 2 endpoints for demonstrating our background jobs and regular endpoint for which user or another service can interact with our system. We also have both <code>startup</code> and <code>shutdown</code> FastAPI event which we will use it to start and stop our RMQ producer and consumer.</p><p>Let&rsquo;s start with setup the producer.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python3 data-lang=python3><span style=display:flex><span><span style=color:#a6e22e>@app.on_event</span>(<span style=color:#e6db74>&#34;startup&#34;</span>)
</span></span><span style=display:flex><span><span style=color:#66d9ef>async</span> <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>start_rmq</span>():
</span></span><span style=display:flex><span>    <span style=color:#75715e># start producer</span>
</span></span><span style=display:flex><span>    app<span style=color:#f92672>.</span>rmq_producer <span style=color:#f92672>=</span> PikaClient(queue_name<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;test.queue&#34;</span>,
</span></span><span style=display:flex><span>                                  exchange_name<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;test.exchange&#34;</span>,
</span></span><span style=display:flex><span>                                  conn_str<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;amqp://root:root@127.0.0.1:5672&#34;</span>)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>await</span> app<span style=color:#f92672>.</span>rmq_producer<span style=color:#f92672>.</span>start_producer()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>@app.on_event</span>(<span style=color:#e6db74>&#34;shutdown&#34;</span>)
</span></span><span style=display:flex><span><span style=color:#66d9ef>async</span> <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>shutdown_rmq</span>():
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>await</span> app<span style=color:#f92672>.</span>rmq_producer<span style=color:#f92672>.</span>disconnect()
</span></span></code></pre></div><p>Quite simple, once the application start it will create a <code>PikaClient</code> object and call <code>start_producer()</code> to run it as producer. And once the application is stopped it will call the <code>disconnect()</code> to stop the producer.</p><p>Now, let&rsquo;s implement the similar thing to consumer with slight difference. We will run the consumer in a different thread so it won&rsquo;t block the thread that FastAPI used for serving endpoint routes.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python3 data-lang=python3><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>start_background_loop</span>(loop: asyncio<span style=color:#f92672>.</span>AbstractEventLoop) <span style=color:#f92672>-&gt;</span> <span style=color:#66d9ef>None</span>:
</span></span><span style=display:flex><span>    <span style=color:#75715e># inspired from https://gist.github.com/dmfigol/3e7d5b84a16d076df02baa9f53271058</span>
</span></span><span style=display:flex><span>    asyncio<span style=color:#f92672>.</span>set_event_loop(loop)
</span></span><span style=display:flex><span>    loop<span style=color:#f92672>.</span>run_forever()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>@app.on_event</span>(<span style=color:#e6db74>&#34;startup&#34;</span>)
</span></span><span style=display:flex><span><span style=color:#66d9ef>async</span> <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>start_rmq</span>():
</span></span><span style=display:flex><span>    <span style=color:#75715e># start producer</span>
</span></span><span style=display:flex><span>    app<span style=color:#f92672>.</span>rmq_producer <span style=color:#f92672>=</span> PikaClient(queue_name<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;test.queue&#34;</span>,
</span></span><span style=display:flex><span>                                        exchange_name<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;test.exchange&#34;</span>,
</span></span><span style=display:flex><span>                                        conn_str<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;amqp://root:root@127.0.0.1:5672&#34;</span>)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>await</span> app<span style=color:#f92672>.</span>rmq_producer<span style=color:#f92672>.</span>start_producer()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e># start consumer in other thread</span>
</span></span><span style=display:flex><span>    app<span style=color:#f92672>.</span>rmq_consumer <span style=color:#f92672>=</span> PikaClient(queue_name<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;test.queue&#34;</span>,
</span></span><span style=display:flex><span>                                  exchange_name<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;test.exchange&#34;</span>,
</span></span><span style=display:flex><span>                                  conn_str<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;amqp://root:root@127.0.0.1:5672&#34;</span>)
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    app<span style=color:#f92672>.</span>consumer_loop <span style=color:#f92672>=</span> asyncio<span style=color:#f92672>.</span>new_event_loop()
</span></span><span style=display:flex><span>    tloop <span style=color:#f92672>=</span> threading<span style=color:#f92672>.</span>Thread(target<span style=color:#f92672>=</span>start_background_loop, args<span style=color:#f92672>=</span>(app<span style=color:#f92672>.</span>consumer_loop,), daemon<span style=color:#f92672>=</span><span style=color:#66d9ef>True</span>)
</span></span><span style=display:flex><span>    tloop<span style=color:#f92672>.</span>start()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    _ <span style=color:#f92672>=</span> asyncio<span style=color:#f92672>.</span>run_coroutine_threadsafe(app<span style=color:#f92672>.</span>rmq_consumer<span style=color:#f92672>.</span>start_consumer(), app<span style=color:#f92672>.</span>consumer_loop)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>@app.on_event</span>(<span style=color:#e6db74>&#34;shutdown&#34;</span>)
</span></span><span style=display:flex><span><span style=color:#66d9ef>async</span> <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>shutdown_rmq</span>():
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>await</span> app<span style=color:#f92672>.</span>rmq_producer<span style=color:#f92672>.</span>disconnect()
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>await</span> app<span style=color:#f92672>.</span>rmq_consumer<span style=color:#f92672>.</span>disconnect()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    app<span style=color:#f92672>.</span>consumer_loop<span style=color:#f92672>.</span>stop()
</span></span></code></pre></div><p>Here, inside the <code>startup</code> event we initiated a new asyncio event loop. Then, we trigger that loop to be run from another thread. We then delegate the <code>start_consumer()</code> calls to the loop, so the consumer will executed in the newly created thread. Finally, inside the <code>shutdown</code> event, we also call <code>disconnect()</code> to stop consumer RMQ from subscribing the queue. And we also trigger our created asyncio event loop to stop.</p><p>The final codes would be like this.</p><p><code>rmq.py</code></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python3 data-lang=python3><span style=display:flex><span><span style=color:#f92672>import</span> logging
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> aio_pika
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> asyncio
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>logger <span style=color:#f92672>=</span> logging<span style=color:#f92672>.</span>getLogger(__name__)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>PikaClient</span>():
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> __init__(self, queue_name: str, exchange_name: str, conn_str: str) <span style=color:#f92672>-&gt;</span> <span style=color:#66d9ef>None</span>:
</span></span><span style=display:flex><span>        self<span style=color:#f92672>.</span>queue_name <span style=color:#f92672>=</span> queue_name
</span></span><span style=display:flex><span>        self<span style=color:#f92672>.</span>exchange_name <span style=color:#f92672>=</span> exchange_name
</span></span><span style=display:flex><span>        self<span style=color:#f92672>.</span>conn_str <span style=color:#f92672>=</span> conn_str
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        self<span style=color:#f92672>.</span>connection <span style=color:#f92672>=</span> <span style=color:#66d9ef>None</span>
</span></span><span style=display:flex><span>        self<span style=color:#f92672>.</span>channel <span style=color:#f92672>=</span> <span style=color:#66d9ef>None</span>
</span></span><span style=display:flex><span>        self<span style=color:#f92672>.</span>exchange <span style=color:#f92672>=</span> <span style=color:#66d9ef>None</span>
</span></span><span style=display:flex><span>        self<span style=color:#f92672>.</span>queue <span style=color:#f92672>=</span> <span style=color:#66d9ef>None</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>async</span> <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>start_connection</span>(self):
</span></span><span style=display:flex><span>        logger<span style=color:#f92672>.</span>info(<span style=color:#e6db74>&#34;Starting a new connection&#34;</span>)
</span></span><span style=display:flex><span>        self<span style=color:#f92672>.</span>connection <span style=color:#f92672>=</span> <span style=color:#66d9ef>await</span> aio_pika<span style=color:#f92672>.</span>connect_robust(url<span style=color:#f92672>=</span>self<span style=color:#f92672>.</span>conn_str)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        logger<span style=color:#f92672>.</span>info(<span style=color:#e6db74>&#34;Opening a new channel&#34;</span>)
</span></span><span style=display:flex><span>        self<span style=color:#f92672>.</span>channel <span style=color:#f92672>=</span> <span style=color:#66d9ef>await</span> self<span style=color:#f92672>.</span>connection<span style=color:#f92672>.</span>channel()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        logger<span style=color:#f92672>.</span>info(<span style=color:#e6db74>&#34;Declaring an exchange: </span><span style=color:#e6db74>%s</span><span style=color:#e6db74>&#34;</span> <span style=color:#f92672>%</span> self<span style=color:#f92672>.</span>exchange_name)
</span></span><span style=display:flex><span>        self<span style=color:#f92672>.</span>exchange <span style=color:#f92672>=</span> <span style=color:#66d9ef>await</span> self<span style=color:#f92672>.</span>channel<span style=color:#f92672>.</span>declare_exchange(name<span style=color:#f92672>=</span>self<span style=color:#f92672>.</span>exchange_name, type<span style=color:#f92672>=</span>aio_pika<span style=color:#f92672>.</span>ExchangeType<span style=color:#f92672>.</span>DIRECT)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>await</span> self<span style=color:#f92672>.</span>setup_queue()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>async</span> <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>setup_queue</span>(self):
</span></span><span style=display:flex><span>        logger<span style=color:#f92672>.</span>info(<span style=color:#e6db74>&#34;Setup a queue: </span><span style=color:#e6db74>%s</span><span style=color:#e6db74>&#34;</span> <span style=color:#f92672>%</span> self<span style=color:#f92672>.</span>queue_name)
</span></span><span style=display:flex><span>        self<span style=color:#f92672>.</span>queue <span style=color:#f92672>=</span> <span style=color:#66d9ef>await</span> self<span style=color:#f92672>.</span>channel<span style=color:#f92672>.</span>declare_queue(name<span style=color:#f92672>=</span>self<span style=color:#f92672>.</span>queue_name)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        logger<span style=color:#f92672>.</span>info(<span style=color:#e6db74>&#34;Bind queue to exchange&#34;</span>)
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>await</span> self<span style=color:#f92672>.</span>queue<span style=color:#f92672>.</span>bind(self<span style=color:#f92672>.</span>exchange)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>async</span> <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>start_producer</span>(self):
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>await</span> self<span style=color:#f92672>.</span>start_connection()
</span></span><span style=display:flex><span>        logger<span style=color:#f92672>.</span>info(<span style=color:#e6db74>&#34;Producer has been started&#34;</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> self
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>async</span> <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>publish_message</span>(self, message):
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>await</span> self<span style=color:#f92672>.</span>exchange<span style=color:#f92672>.</span>publish(
</span></span><span style=display:flex><span>            aio_pika<span style=color:#f92672>.</span>Message(body<span style=color:#f92672>=</span>message<span style=color:#f92672>.</span>encode()),
</span></span><span style=display:flex><span>            routing_key<span style=color:#f92672>=</span>self<span style=color:#f92672>.</span>queue_name
</span></span><span style=display:flex><span>        )
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>async</span> <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>start_consumer</span>(self):
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>await</span> self<span style=color:#f92672>.</span>start_connection()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>await</span> self<span style=color:#f92672>.</span>channel<span style=color:#f92672>.</span>set_qos(prefetch_count<span style=color:#f92672>=</span><span style=color:#ae81ff>1</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        logger<span style=color:#f92672>.</span>info(<span style=color:#e6db74>&#34;Starting consumer&#34;</span>)
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>await</span> self<span style=color:#f92672>.</span>queue<span style=color:#f92672>.</span>consume(self<span style=color:#f92672>.</span>handle_message)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        logger<span style=color:#f92672>.</span>info(<span style=color:#e6db74>&#34;Consumer has been started&#34;</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> self
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>async</span> <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>handle_message</span>(self, message: aio_pika<span style=color:#f92672>.</span>abc<span style=color:#f92672>.</span>AbstractIncomingMessage):
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e># simulating long process</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>await</span> asyncio<span style=color:#f92672>.</span>sleep(<span style=color:#ae81ff>10</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        logger<span style=color:#f92672>.</span>info(<span style=color:#e6db74>&#34;Consumer: Got message from producer: </span><span style=color:#e6db74>%s</span><span style=color:#e6db74>&#34;</span> <span style=color:#f92672>%</span> message<span style=color:#f92672>.</span>body<span style=color:#f92672>.</span>decode())
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>await</span> message<span style=color:#f92672>.</span>ack()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>async</span> <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>disconnect</span>(self):
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>try</span>:
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> <span style=color:#f92672>not</span> self<span style=color:#f92672>.</span>connection<span style=color:#f92672>.</span>is_closed:
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>await</span> self<span style=color:#f92672>.</span>connection<span style=color:#f92672>.</span>close()
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>except</span> <span style=color:#a6e22e>Exception</span> <span style=color:#66d9ef>as</span> _e:
</span></span><span style=display:flex><span>            logger<span style=color:#f92672>.</span>error(_e)
</span></span></code></pre></div><br><p><code>main.py</code></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python3 data-lang=python3><span style=display:flex><span><span style=color:#f92672>from</span> fastapi <span style=color:#f92672>import</span> FastAPI, Request, Response
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> asyncio
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> logging
</span></span><span style=display:flex><span><span style=color:#f92672>from</span> rmq <span style=color:#f92672>import</span> PikaClient
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> threading
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>logging<span style=color:#f92672>.</span>basicConfig(level<span style=color:#f92672>=</span>logging<span style=color:#f92672>.</span>INFO, format<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;</span><span style=color:#e6db74>%(asctime)s</span><span style=color:#e6db74> </span><span style=color:#e6db74>%(levelname)s</span><span style=color:#e6db74>: </span><span style=color:#e6db74>%(name)s</span><span style=color:#e6db74> - </span><span style=color:#e6db74>%(message)s</span><span style=color:#e6db74>&#34;</span>)
</span></span><span style=display:flex><span>logger <span style=color:#f92672>=</span> logging<span style=color:#f92672>.</span>getLogger(__name__)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>app <span style=color:#f92672>=</span> FastAPI()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>start_background_loop</span>(loop: asyncio<span style=color:#f92672>.</span>AbstractEventLoop) <span style=color:#f92672>-&gt;</span> <span style=color:#66d9ef>None</span>:
</span></span><span style=display:flex><span>    <span style=color:#75715e># inspired from https://gist.github.com/dmfigol/3e7d5b84a16d076df02baa9f53271058</span>
</span></span><span style=display:flex><span>    asyncio<span style=color:#f92672>.</span>set_event_loop(loop)
</span></span><span style=display:flex><span>    loop<span style=color:#f92672>.</span>run_forever()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>@app.on_event</span>(<span style=color:#e6db74>&#34;startup&#34;</span>)
</span></span><span style=display:flex><span><span style=color:#66d9ef>async</span> <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>start_rmq</span>():
</span></span><span style=display:flex><span>    <span style=color:#75715e># start producer</span>
</span></span><span style=display:flex><span>    app<span style=color:#f92672>.</span>rmq_producer <span style=color:#f92672>=</span> PikaClient(queue_name<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;test.queue&#34;</span>,
</span></span><span style=display:flex><span>                                        exchange_name<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;test.exchange&#34;</span>,
</span></span><span style=display:flex><span>                                        conn_str<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;amqp://root:root@127.0.0.1:5672&#34;</span>)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>await</span> app<span style=color:#f92672>.</span>rmq_producer<span style=color:#f92672>.</span>start_producer()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e># start consumer in other thread</span>
</span></span><span style=display:flex><span>    app<span style=color:#f92672>.</span>rmq_consumer <span style=color:#f92672>=</span> PikaClient(queue_name<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;test.queue&#34;</span>,
</span></span><span style=display:flex><span>                                  exchange_name<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;test.exchange&#34;</span>,
</span></span><span style=display:flex><span>                                  conn_str<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;amqp://root:root@127.0.0.1:5672&#34;</span>)
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    app<span style=color:#f92672>.</span>consumer_loop <span style=color:#f92672>=</span> asyncio<span style=color:#f92672>.</span>new_event_loop()
</span></span><span style=display:flex><span>    tloop <span style=color:#f92672>=</span> threading<span style=color:#f92672>.</span>Thread(target<span style=color:#f92672>=</span>start_background_loop, args<span style=color:#f92672>=</span>(app<span style=color:#f92672>.</span>consumer_loop,), daemon<span style=color:#f92672>=</span><span style=color:#66d9ef>True</span>)
</span></span><span style=display:flex><span>    tloop<span style=color:#f92672>.</span>start()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    _ <span style=color:#f92672>=</span> asyncio<span style=color:#f92672>.</span>run_coroutine_threadsafe(app<span style=color:#f92672>.</span>rmq_consumer<span style=color:#f92672>.</span>start_consumer(), app<span style=color:#f92672>.</span>consumer_loop)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>@app.on_event</span>(<span style=color:#e6db74>&#34;shutdown&#34;</span>)
</span></span><span style=display:flex><span><span style=color:#66d9ef>async</span> <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>shutdown_rmq</span>():
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>await</span> app<span style=color:#f92672>.</span>rmq_producer<span style=color:#f92672>.</span>disconnect()
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>await</span> app<span style=color:#f92672>.</span>rmq_consumer<span style=color:#f92672>.</span>disconnect()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    app<span style=color:#f92672>.</span>consumer_loop<span style=color:#f92672>.</span>stop()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>@app.get</span>(<span style=color:#e6db74>&#34;/&#34;</span>)
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>root</span>(response: Response):
</span></span><span style=display:flex><span>    response<span style=color:#f92672>.</span>status_code <span style=color:#f92672>=</span> <span style=color:#ae81ff>200</span>
</span></span><span style=display:flex><span>    logger<span style=color:#f92672>.</span>info(<span style=color:#e6db74>&#34;hit root endpoint&#34;</span>)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> {<span style=color:#e6db74>&#34;status_code&#34;</span>: <span style=color:#ae81ff>200</span>, <span style=color:#e6db74>&#34;message&#34;</span>: <span style=color:#e6db74>&#34;Hello!&#34;</span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>@app.get</span>(<span style=color:#e6db74>&#34;/send-message&#34;</span>)
</span></span><span style=display:flex><span><span style=color:#66d9ef>async</span> <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>send_message</span>(request: Request, response: Response):
</span></span><span style=display:flex><span>    message <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;Hello from RMQ producer!&#34;</span>
</span></span><span style=display:flex><span>    response<span style=color:#f92672>.</span>status_code <span style=color:#f92672>=</span> <span style=color:#ae81ff>202</span>
</span></span><span style=display:flex><span>    logger<span style=color:#f92672>.</span>info(<span style=color:#e6db74>&#34;message sent&#34;</span>)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>await</span> request<span style=color:#f92672>.</span>app<span style=color:#f92672>.</span>rmq_producer<span style=color:#f92672>.</span>publish_message(message)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> {<span style=color:#e6db74>&#34;status_code&#34;</span>: <span style=color:#ae81ff>202</span>, <span style=color:#e6db74>&#34;message&#34;</span>: <span style=color:#e6db74>&#34;Your message has been sent.&#34;</span>}
</span></span></code></pre></div><h2 id=running-the-application>Running the Application<a hidden class=anchor aria-hidden=true href=#running-the-application>#</a></h2><p>When we start the server, shortly we will notice both producer and consumer has started.
<img loading=lazy src=images/serverstart.png#center alt="Starting server"></p><p>Now, lets try to hit the long process endpoint following by several hits to the ordinary endpoint.
<img loading=lazy src=images/endpointhit.png#center alt="Hit enpoint simulation"></p><p>Let&rsquo;s try several more then observe our RMQ dashboard.
<img loading=lazy src=images/rmq_dashboard.png#center alt="RMQ dashboard"></p><p>And we can see there are some messages incoming and being processed.</p><h2 id=conclusion>Conclusion<a hidden class=anchor aria-hidden=true href=#conclusion>#</a></h2><p>Now we know how to integrate both RMQ based publisher and subscriber within single FastAPI app.</p><p>If you have any inquiries, comments, suggestions, or critics please don’t hesitate to reach me out:</p><ul><li>Mail: <a href=mailto:affahrizain@gmail.com>affahrizain@gmail.com</a></li><li>LinkedIn: <a href=https://www.linkedin.com/in/fahrizainn/>https://www.linkedin.com/in/fahrizainn/</a></li><li>GitHub: <a href=https://github.com/fhrzn>https://github.com/fhrzn</a></li></ul><p>Until next time! 👋</p><hr><h2 id=references>References<a hidden class=anchor aria-hidden=true href=#references>#</a></h2><ol><li><a href=https://www.rabbitmq.com/tutorials/tutorial-one-python.html>https://www.rabbitmq.com/tutorials/tutorial-one-python.html</a></li><li><a href=https://aio-pika.readthedocs.io/en/latest/quick-start.html#asynchronous-message-processing>https://aio-pika.readthedocs.io/en/latest/quick-start.html#asynchronous-message-processing</a></li><li><a href=https://itracer.medium.com/rabbitmq-publisher-and-consumer-with-fastapi-175fe87aefe1>RabbitMQ publisher and consumer with FastAPI by IT racer</a></li><li><a href=https://gist.github.com/dmfigol/3e7d5b84a16d076df02baa9f53271058>Gist python asyncio event loop in a separated thread by dmfigol</a></li></ol></div><footer class=post-footer><ul class=post-tags><li><a href=https://fhrzn.github.io/tags/event-driven/>event-driven</a></li><li><a href=https://fhrzn.github.io/tags/messagebroker/>messagebroker</a></li><li><a href=https://fhrzn.github.io/tags/python/>python</a></li></ul><nav class=paginav><a class=prev href=https://fhrzn.github.io/posts/building-conversational-ai-context-aware-chatbot/><span class=title>« Prev</span><br><span>Building Conversational AI with LangChain: Techniques for Context Retention in Chatbots</span>
</a><a class=next href=https://fhrzn.github.io/posts/restore-your-noisy-image-using-autoencoders/><span class=title>Next »</span><br><span>Restore your Noisy Image Using Autoencoders</span></a></nav></footer><script src=https://giscus.app/client.js data-repo=fhrzn/fhrzn.github.io data-repo-id=R_kgDOK-oOOw data-category=Q&A data-category-id=DIC_kwDOK-oOO84CcI9D data-mapping=title data-strict=0 data-reactions-enabled=1 data-emit-metadata=1 data-input-position=top data-theme=preferred_color_scheme data-lang=en data-loading=lazy crossorigin=anonymous async></script></article></main><footer class=footer><span>&copy; 2024 <a href=https://fhrzn.github.io/>fahrizain</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>